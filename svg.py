#!/usr/bin/env python3
"""
Convert GeoJSON (or any vector file supported by geopandas) to an SVG outline.
Saves a single SVG file with path(s) representing the geometry.

Usage:
    python geojson_to_svg.py path/to/malawi.geojson out/malawi-outline.svg
"""

import sys
import math
from pathlib import Path
import geopandas as gpd
from shapely.geometry import mapping, Polygon, MultiPolygon, shape

# -------- Configuration --------
SIMPLIFY_TOLERANCE_METERS = 100  # set to 0 to disable simplification
TARGET_PIXEL_WIDTH = 400         # desired SVG width in pixels
PADDING_PX = 8                   # padding around drawing in pixels
STROKE_WIDTH = 0.8               # visual stroke width in SVG units
FILL_COLOR = "#e6f4ea"
STROKE_COLOR = "#1f2937"
# --------------------------------

def geom_to_path_coords(geom):
    """Return list of rings: each ring is list of (x,y) points."""
    coords_list = []
    if isinstance(geom, Polygon):
        # exterior then interiors (holes)
        coords_list.append(list(geom.exterior.coords))
        for interior in geom.interiors:
            coords_list.append(list(interior.coords))
    elif isinstance(geom, MultiPolygon):
        for poly in geom.geoms:
            coords_list.extend(geom_to_path_coords(poly))
    else:
        raise ValueError("Unsupported geometry type: " + type(geom).__name__)
    return coords_list

def build_path_d(rings, transform_fn):
    """
    Convert list of rings into an SVG path 'd' string.
    transform_fn maps (x,y) -> (sx, sy) in SVG coords.
    Outer ring is drawn with M/L...Z, holes are drawn as subpaths (SVG supports winding rules).
    """
    parts = []
    for ring in rings:
        if len(ring) == 0:
            continue
        sx, sy = transform_fn(ring[0])
        seg = [f"M {sx:.2f} {sy:.2f}"]
        for (x, y) in ring[1:]:
            tx, ty = transform_fn((x, y))
            seg.append(f"L {tx:.2f} {ty:.2f}")
        seg.append("Z")
        parts.append(" ".join(seg))
    return " ".join(parts)

def main(src_path, out_svg_path):
    src = Path(src_path)
    out = Path(out_svg_path)
    if not src.exists():
        raise SystemExit(f"Input file not found: {src}")

    # load
    gdf = gpd.read_file(str(src))
    if gdf.empty:
        raise SystemExit("No geometry found in file.")

    # dissolve all features to a single geometry (optional)
    geom = gdf.unary_union

    # project to Web Mercator for distance-preserving simplification
    # keep original CRS if absent assume EPSG:4326
    if gdf.crs is None:
        gdf = gdf.set_crs(epsg=4326)
    geom_merc = gpd.GeoSeries([geom], crs=gdf.crs).to_crs(epsg=3857).iloc[0]

    # simplify if desired (tolerance in meters because mercator)
    if SIMPLIFY_TOLERANCE_METERS and SIMPLIFY_TOLERANCE_METERS > 0:
        geom_merc = geom_merc.simplify(SIMPLIFY_TOLERANCE_METERS, preserve_topology=True)

    # get bounds in mercator meters
    minx, miny, maxx, maxy = geom_merc.bounds
    width_m = maxx - minx
    height_m = maxy - miny
    if width_m == 0 or height_m == 0:
        raise SystemExit("Invalid geometry bounds (zero width/height).")

    # target pixel height based on aspect ratio
    target_w = TARGET_PIXEL_WIDTH - 2 * PADDING_PX
    aspect = height_m / width_m
    target_h = max(1, int(target_w * aspect))

    svg_w = target_w + 2 * PADDING_PX
    svg_h = target_h + 2 * PADDING_PX

    # compute scale factors from mercator meters -> svg pixels
    sx = target_w / width_m
    sy = target_h / height_m
    # keep uniform scale to preserve aspect ratio
    s = min(sx, sy)

    # transformation: mercator meters (x,y) -> svg coords (px,py)
    # and invert Y because SVG Y grows downwards; mercator Y grows upwards
    def transform(pt):
        x, y = pt
        px = (x - minx) * s + PADDING_PX
        py = target_h - (y - miny) * s + PADDING_PX  # invert Y
        return px, py

    # convert geometry back to lon/lat? No â€” we'll use projected coords from geom_merc directly.
    # Extract polygons/rings from geom_merc (which is in EPSG:3857)
    rings = []
    if isinstance(geom_merc, (Polygon, MultiPolygon)):
        # for shapely 2: use geom_merc.geoms for MultiPolygon
        rings = geom_to_path_coords(geom_merc)
    else:
        # try to coerce
        geom2 = shape(mapping(geom_merc))
        rings = geom_to_path_coords(geom2)

    # build the path 'd'
    d = build_path_d(rings, transform)

    # minimal svg content
    svg = f"""<?xml version="1.0" encoding="UTF-8"?>
<svg xmlns="http://www.w3.org/2000/svg" width="{svg_w:.0f}" height="{svg_h:.0f}" viewBox="0 0 {svg_w:.2f} {svg_h:.2f}" preserveAspectRatio="xMidYMid meet">
  <title>Malawi outline (derived from GeoJSON)</title>
  <desc>Generated by geojson_to_svg.py</desc>
  <g transform="">
    <path d="{d}"
          fill="{FILL_COLOR}"
          stroke="{STROKE_COLOR}"
          stroke-width="{STROKE_WIDTH}"
          stroke-linejoin="round"
          stroke-linecap="round"
          />          
  </g>
</svg>
"""    

    out.parent.mkdir(parents=True, exist_ok=True)
    out.write_text(svg, encoding="utf-8")
    print(f"Wrote SVG -> {out} (size: {svg_w:.0f}x{svg_h:.0f}px)")

if __name__ == "__main__":
    if len(sys.argv) < 3:    
        print("Usage: python geojson_to_svg.py input.geojson output.svg")
        sys.exit(1)
    main(sys.argv[1], sys.argv[2])
      